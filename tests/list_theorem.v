Require Import Effects.Exception.

Inductive nat@{i}: Type@{i} :=
| O: nat
| S: nat -> nat.

Notation "0" := O.

Inductive list (A: Type): Type :=
| nil: list A
| cons: A -> list A -> list A.

Arguments cons {_} _ _.
Arguments nil {_}.

Notation "x :: l" := (cons x l).

Inductive le: nat -> nat -> Prop :=
| le_O: le 0 0
| le_O_S: forall n, le 0 (S n)
| le_S: forall n m, le n m -> le (S n) (S m).

Infix "<=" := le.

Definition lt n m := S n <= m.

Infix "<" := lt.

Definition gt (n m:nat) := m < n.

Infix ">" := gt.

Effect List Translate nat list.
Effect List Translate True and not le lt gt eq.

(** This could be generated by the plugin *)
Effect List Translate list_rect le_ind eq_ind.
Scheme listᵒ_ind := Induction for listᵒ Sort Prop.

Effect Definition catch_list_prop:
  forall (A : Type) (P : list A -> Prop),
    P nil ->
    (forall (H : A) (H0 : list A), P H0 -> P (H :: H0)) ->
    (forall e : Exception, P (raise (list A) e)) ->
    forall H : list A, P H.
Proof.
  intros E A P Pnil Pcons Praise l; induction l; auto. apply Praise.
Defined.
(* ** *)

Effect List Translate eq_sym eq_ind_r.

(** Propositional equalities *)
Effect Definition catch_nat_O:
  forall P PO PS Praise,
    catch_nat P PO PS Praise O = PO.
Proof.
  reflexivity.
Defined.

Effect Definition catch_nat_S:
  forall P PO PS Praise n,
    catch_nat P PO PS Praise (S n) = PS n (catch_nat P PO PS Praise n).
Proof.
  reflexivity.
Defined.

Effect Definition catch_nat_raise:
  forall P PO PS Praise e,
    catch_nat P PO PS Praise (raise nat e) = Praise e.
Proof.
  reflexivity.
Defined.

Effect Definition catch_list_nil:
  forall A P Pnil Pcons Praise,
    catch_list A P Pnil Pcons Praise nil = Pnil.
Proof.
  reflexivity.
Defined.

Effect Definition catch_list_cons:
  forall A P Pnil Pcons Praise a l,
    catch_list A P Pnil Pcons Praise (cons a l) = Pcons a l (catch_list A P Pnil Pcons Praise l).
Proof.
  reflexivity.
Defined.

Effect Definition catch_list_raise:
  forall A P Pnil Pcons Praise e,
    catch_list A P Pnil Pcons Praise (raise _ e) = Praise e.
Proof.
  reflexivity.
Defined.

Effect Definition list_rect_raise:
  forall A P Pnil Pcons e,
    list_rect A P Pnil Pcons (raise _ e) = raise _ e.
Proof.
  reflexivity.
Defined.
(* ** *)

Definition head {A: Type} (l: list A) e: A :=
  list_rect A (fun _ => A) (raise _ e) (fun x _ _ => x) l.

Definition tail {A: Type} (l: list A) e: list A :=
  list_rect A (fun _ => list A) (raise _ e) (fun _ l _ => l) l.

Definition length {A: Type} (l: list A): nat :=
  list_rect A (fun _ => nat) 0 (fun _ l n => S n) l.

Theorem head_raise:
  forall A e, head (raise (list A) e) e = raise A e.
Proof.
  intros. unfold head. rewrite list_rect_raise. reflexivity.
Defined.

Theorem tail_raise:
  forall A e, tail (raise (list A) e) e = raise (list A) e.
Proof.
  intros. unfold tail. rewrite list_rect_raise. reflexivity.
Defined.

Theorem length_raise:
  forall A e, length (raise (list A) e) = raise nat e.
Proof.
  intros. unfold length. rewrite list_rect_raise. reflexivity.
Defined.

Theorem length_cons_raise:
  forall A a e, length (cons a (raise (list A) e)) = S (raise nat e).
Proof.
  intros. unfold length. simpl. rewrite list_rect_raise. reflexivity.
Defined.

Effect List Translate head tail length.
Effect List Translate head_raise tail_raise length_raise.

Theorem nil_not_raise: forall A e, @nil A <> raise (list A) e.
Proof.
  intros A e.
  assert
    (H: forall l',
        @nil A = l' ->
        (catch_list _ (fun _ => Prop) True (fun _ _ _ => True) (fun _ => False) l')).
  - intros l' Heq. destruct Heq. rewrite catch_list_nil. exact I.
  - intros Heq. specialize (H (raise _ e) Heq). rewrite catch_list_raise in H. exact H.
Defined.
Effect Translate nil_not_raise.

Theorem cons_not_raise: forall A a l e, cons a l <> raise (list A) e.
Proof.
  intros A a l e.
  assert (
      H: forall l',
        cons a l = l' ->
        (catch_list _ (fun _ => Prop) True (fun _ _ _ => True) (fun _ => False) l')
    ).
  - intros l' Heq. destruct Heq. rewrite catch_list_cons. exact I.
  - intros Heq. specialize (H (raise _ e) Heq). rewrite catch_list_raise in H. exact H.
Defined.
Effect Translate cons_not_raise.

Theorem raise_not_le: forall n e, n <= raise _ e -> False.
Proof.
  intros n e.
  assert (
      H: forall n',
        n <= n' ->
        catch_nat (fun _ => Prop) True (fun _ _ => True) (fun _ => False) n'
    ).
  - intros n' Hle. induction Hle.
    + rewrite catch_nat_O. exact I.
    + rewrite catch_nat_S. exact I.
    + rewrite catch_nat_S. exact I.
  - intros Hle. specialize (H (raise _ e) Hle).
    rewrite catch_nat_raise in H.
    exact H.
Defined.
Effect Translate raise_not_le.

Theorem non_empty_list_distinct_raise:
  forall n A e (l: list A),
    n <= length l -> l <> raise _ e.
Proof.
  intros n A e l Hle Heq. rewrite Heq in Hle.
  unfold length in Hle. rewrite list_rect_raise in Hle.
  exact (raise_not_le n e Hle).
Defined.
Effect Translate non_empty_list_distinct_raise.

Theorem list_param_distinct_raise:
  forall A e (l: list A),
    param l -> l <> raise _ e.
Proof.
  intros A e l HP Heq.
  refine (list_ind_param A (fun l => param l -> l <> raise _ e) _ _ l HP HP Heq); clear HP Heq.
  - intros HP Heq. rewrite Heq in HP. exact (param_correct e HP).
  - clear l; intros a l IH HP Heq. rewrite Heq in HP. exact (param_correct e HP).
Defined.
Effect Translate list_param_distinct_raise.

Theorem S_not_O: forall n, S n = 0 -> False.
Proof.
  intros n.
  assert (
      H: forall m,
        0 = m ->
        catch_nat (fun _ => Prop) True (fun _ _ => False) (fun _ => False) m
    ).
  + intros m Heq. induction Heq. rewrite catch_nat_O. exact I.
  + intros Heq. specialize (H (S n) (eq_sym Heq)). rewrite catch_nat_S in H. exact H.
Defined.
Effect Translate S_not_O.

Theorem O_not_le_O :
  S O <= 0 -> False.
Proof.
  assert (
      H: forall n m,
        n <= m -> catch_nat (fun _ => Prop) True (fun _ _ => m = 0 -> False) (fun _ => m = 0) n
    ).
  - intros n m Hle. induction Hle.
    + rewrite catch_nat_O . exact I.
    + rewrite catch_nat_O . exact I.
    + rewrite catch_nat_S. intros Heq. exact (S_not_O m Heq).
  - intros Hle. specialize (H (S 0) 0 Hle). rewrite catch_nat_S in H. exact (H eq_refl).
Defined.
Effect Translate O_not_le_O.

Effect Definition le_S_n: forall n m, S n <= S m -> n <= m.
 Proof.
  intros E n m H; inversion H; subst; auto.
Defined.

Theorem non_empty_list_distinct_tail_raise:
  forall A e (l: list A),
    0 < length l -> tail l e <> raise _ e.
Proof.
  intros A e l; induction l using catch_list_prop; cbn.
  - intros Hle Heq. exact (O_not_le_O Hle).
  - intros Hle Heq. apply le_S_n in Hle. rewrite Heq in Hle.
    rewrite list_rect_raise in Hle. exact(raise_not_le 0 e Hle).
  - intros Habs Hle. unfold length in Habs. rewrite list_rect_raise in Habs.
    exact (raise_not_le (S 0) e0 Habs).
Defined.
Effect Translate non_empty_list_distinct_tail_raise.

Definition list_param_deep {A} `{Param A} (l: list  A): Prop :=
  catch_list A (fun _ => Prop) True (fun a _ p => p /\ param a) (fun _ => False) l.
Effect Translate list_param_deep.

Theorem non_empty_deep_param_list_head_not_raise:
  forall A `{Param A} e (l: list A),
    length l > 0 -> list_param_deep l -> head l e <> raise _ e.
Proof.
  intros A Param e l; induction l using catch_list_prop; cbn; intros Hle HP Hhead.
  - exact (O_not_le_O Hle).
  - unfold list_param_deep in HP. rewrite catch_list_cons in HP. destruct HP as [_ H1].
    rewrite Hhead in H1. exact (param_correct e H1).
  - unfold list_param_deep in HP. rewrite catch_list_raise in HP. exact HP.
Defined.
Effect Translate non_empty_deep_param_list_head_not_raise.
